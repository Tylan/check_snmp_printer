#!/usr/bin/perl
#########################################################
#                                                       #
#                                                       #
#             SNMP Printer Check Plugin                 #
#                        for                            #
#                  Icinga / Nagios                      #
#                                                       #
#          Version 2.0.2 (May 18, 2023)                 #
#                by Bob McLoughlin                      #
#         E-mail: rmcloughlin@outlook.com               #
#                                                       #
#                                                       #
# Based on:                                             #
# check_snmp_printer (Perl)                             #
#       Version 1.6 (September 08, 2014)                #
# ( by Franky Van Liedekerke                            #
#       E-mail: liedekef@telenet.be )                   #
#                                                       #
# Which was further based on:                           #
# check_snmp_printer.sh                                 #
#       Version 1.5 (January 15, 2010)                  #
# ( by Jason Leonard                                    #
#       E-mail: jason_leonard@yahoo.com )               #
#                                                       #
# Version History                                       #
#   - Refer to CHANGELOG.md                             #
#                                                       #
#       Like the original, this plugin is distributed   #
# under the GNU GPL license. You may re-destribute only #
# according to the terms of the GNU GPL.                #
#                                                       #
#########################################################
#########################################################
#                                                       #
# DEPENDS On                                            #
# SNMP installed (http://www.net-snmp.org/              #
# Nagios plugins installed                              #
#                                                       #
#########################################################

use strict;
use lib qw ( /usr/local/nagios/libexec /usr/lib/nagios/plugins /usr/lib64/nagios/plugins );
use utils qw( %ERRORS $TIMEOUT &print_revision &support &usage );
use SNMP;
use Getopt::Long;
use Data::Dumper;

# globals
use vars qw(
    $PROGNAME $VERSION %procs $snmp $errstr $oid $isip
    $opt_version $opt_help $opt_timeout $opt_retries $opt_host
    $opt_community $opt_snmpver $opt_warning $opt_critical
    $opt_messages $opt_model $opt_consum $opt_tray $opt_pagecount
    $opt_metric $opt_nofeeder $opt_nofuser $opt_user $opt_authpass
    $opt_authkey $opt_authproto $opt_privkey $opt_privpass
    $opt_privproto $opt_contextname $opt_lang $opt_firmware
    $opt_ignoffline $opt_debug $opt_redact $opt_port
);
my (@consumables,@status,@trays,@strays,@percentages,@mresults,@message,@measurables);
my ($state,$statuscode,$EXITSTRING,$snmpcmds,$dbgsnmpcmds,%snmpargs,%dbgsnmpargs,$packedip,$hostip);
my ($i,$tcount,$scount,$traynumber,$cnumber,$mnumber,$critcount,$warncount) = 0;

my %STATUS_CODE =
    ( 'UNKNOWN' => '3', 'OK' => '0', 'WARNING' => '1', 'CRITICAL' => '2' );

# config
$PROGNAME    = $0;
$VERSION     = '2.0.2';

# init options
$opt_version     = undef;
$opt_help        = undef;
$opt_timeout     = $TIMEOUT;
$opt_retries     = 3;
$opt_host        = undef;
$opt_port        = 161;
$opt_community   = 'public';
$opt_snmpver     = 1;
$opt_warning     = 20; # warning percentage: if lower: warning
$opt_critical    = 5;  # critical percentage: if lower: critical
$opt_messages    = undef;
$opt_model       = undef;
$opt_consum      = undef;
$opt_tray        = undef;
$opt_pagecount   = undef;
$opt_metric      = undef;
$opt_user        = undef;
$opt_authpass    = undef;
$opt_authproto   = undef;
$opt_authkey     = undef;
$opt_privpass    = undef;
$opt_privproto   = undef;
$opt_privkey     = undef;
$opt_contextname = undef;
$opt_lang        = undef;
$opt_firmware    = undef;
$opt_ignoffline  = undef;
$opt_debug       = undef;
$opt_redact      = undef;

# get options
Getopt::Long::Configure('bundling');
GetOptions(
    'V|version'           => \$opt_version,
    'h|help'              => \$opt_help,
    't|timeout=i'         => \$opt_timeout,
    'r|retries=i'         => \$opt_retries,
    'H|host=s'            => \$opt_host,
    'p|port=i'            => \$opt_port,
    'C|community=s'       => \$opt_community,
    'v|snmpver=s'         => \$opt_snmpver,
    'w|warning=i'         => \$opt_warning,
    'c|critical=i'        => \$opt_critical,
    'messages'            => \$opt_messages,
    'model'               => \$opt_model,
    'consum'              => \$opt_consum,
    'trays'               => \$opt_tray,
    'pagecount'           => \$opt_pagecount,
    'nofeeder'            => \$opt_nofeeder,
    'nofuser'             => \$opt_nofuser,
    'metric'              => \$opt_metric,
    'firmware'            => \$opt_firmware,
    'ignoreoffline'       => \$opt_ignoffline,
    'redact'              => \$opt_redact,
    'd|debug=i'           => \$opt_debug,
    'u|user=s'            => \$opt_user,
    'A|authpass=s'        => \$opt_authpass,
    'a|authproto=s'       => \$opt_authproto,
    'y|authkey=s'         => \$opt_authkey,
    'X|privpass=s'        => \$opt_privpass,
    'x|privproto=s'       => \$opt_privproto,
    'z|privkey=s'         => \$opt_privkey,
    'n|contextname=s'     => \$opt_contextname,
    'l|lang=s'            => \$opt_lang
) or do {
    print_usage();
    exit($ERRORS{'UNKNOWN'});
};

if ($opt_version) {
    print_version();
    exit($ERRORS{'UNKNOWN'});
}

if ($opt_help) {
    print_help();
    exit($ERRORS{'UNKNOWN'});
}

if (!$opt_host) {
    print "Host option not given\n";
    print_usage();
    exit($ERRORS{'UNKNOWN'});
}

if ($opt_lang) {
    if ($opt_lang =~ m/English|english/) {
        $opt_lang = lc ($opt_lang);
    } else {
        print "Translation to $opt_lang not supported at this time.\n";
        print "Available languages: English\n";
        exit($ERRORS{'UNKNOWN'});
    }
}

# only use one of messages|model|consum|tray|pagecount|firmware options
my $count=0;
($opt_messages) && ($count++);
($opt_model) && ($count++);
($opt_consum) && ($count++);
(defined($opt_tray)) && ($count++);
($opt_pagecount) && ($count++);
($opt_firmware) && ($count++);
if ($count>1) {
    print "Only use one of messages|model|consum|trays|pagecount|firmware options\n";
    print_help();
    exit($ERRORS{'UNKNOWN'});
}
if ($count<1) {
    print "Only use one of messages|model|consum|trays|pagecount|firmware options\n";
    print_help();
    exit($ERRORS{'UNKNOWN'});
}

sub print_usage {
    my $tab = ' ' x length($PROGNAME);
    print <<EOB
Usage:
 check_snmp_printer -H host [-C snmp_community] [-v snmp_version] [-t timeout] [-d level]
 check_snmp_printer --version
 check_snmp_printer --help
EOB
}

sub print_version {
    print_revision($PROGNAME, $VERSION);
}

sub print_help {
    print_version();
    print <<EOB;

Check a printer through SNMP.

EOB

  print_usage();
  print <<EOB;

Required Arguments:
 -H, --host=HOST
    The name or address of the host running SNMP.
 --messages
    Print the messages of the printer
 --model
    Prints the model of the printer
 --pagecount
    Prints the number of pages printed
 --trays
    Checks trays for paper status.
 --consum
    Checks consumables for status.
 --firmware
    Checks current firmware revision and date of printer.

Optional Arguments:
 -p, --port=INTEGER
    The port in which to connect via SNMP.  Default: 161
 -C, --community=STRING
    The community string of the SNMP agent. Default: public
 -v, --snmpver=STRING
    The version of snmp to use.  1 and 2 are supported. Default: 1
 -w, --warning=INTEGER
    The warning limit level to alert on.  0 to disable tray alerting.
 -c, --critical=INTEGER
    The critical limit level to alert on.  0 to disable tray alerting.
 -t, --timeout=INTEGER
    Number of seconds to wait for a response.
 -r, --retries=INTEGER
    Number of retries to try before timing out. Default: 3
 -u, --user=STRING
    User for SNMPv3 authentication
 -A, --authpass=STRING
    SNMPv3 authentication password
 -a, --authproto=STRING
    SNMPv3 authentication protocol
 -y, --authkey=STRING
    SNMPv3 authentication key
 -X, --privpass=STRING
    SNMPv3 privacy password
 -x, --privproto=STRING
    SNMPv3 privacy protocol
 -z, --privkey=STRING
    SNMPv3 privacy key
 -n, --contextname=STRING
    Contextname for SNMPv3
 -d, --debug=INTEGER
    Enables debugging mode level [1 or 2]

 --metric
    Converts output to metric.  Default: imperial
 --nofeeder
    Disables checking of the manual feeder tray
 --nofuser
    Disables checking of the fuser unit
 --ignoreoffline
    Ignores timeouts and sets OK status for powered off printers

EOB
}

sub initialize_snmp {

    if ($opt_debug == 2) { $SNMP::debugging = 2 }

    # Convert timeout to microseconds
    my $stimeout = ($opt_timeout * 250000);

    # Check snmp version, set snmp parameters
    #if (!$opt_authpass) { $opt_authpass = $opt_authkey; }
    #if (!$opt_privpass) { $opt_privpass = $opt_privkey; }

    #base snmp arguments
    %snmpargs = (DestHost      => $hostip,
                 Version       => $opt_snmpver,
                 RemotePort    => $opt_port,
                 Timeout       => $stimeout,
                 Retries       => $opt_retries,
                 UseNumeric    => '1',
    );
    if ($opt_snmpver eq 2) {
        $snmpcmds = "-v" . $opt_snmpver . "c -Cf -On -Oa";
    } else {
        $snmpcmds = "-v$opt_snmpver -Cf -On -Oa";
    }

    #snmp v1 and v2c specific arguments
    my (%snmpv12,%snmpv3);
    if ($opt_snmpver ne 3) {
        %snmpv12 = ( Community  => $opt_community,);
        $snmpcmds .= " -c $opt_community";
    } else { #snmpv3 arguments
        #base
        %snmpv3 = ( SecName     => $opt_user, );
        $snmpcmds .= " -u $opt_user";
    }

    if ( ($opt_user) and ($opt_authproto or $opt_privproto) ) {
        my (%snmpv3pl,%snmpv3ap,%snmpv3pp,%snmpv3aa,%snmpv3pa);

        # Auth Privilege
        if ( $opt_authproto and $opt_privproto ) {
            %snmpv3pl = ( SecLevel   => 'authPriv', );
            $snmpcmds .= " -l authPriv";
        } elsif ( $opt_authproto ) {
            %snmpv3pl = ( SecLevel   => 'authNoPriv', );
            $snmpcmds .= " -l authNoPriv";
        } else {
            %snmpv3pl = ( SecLevel   => 'noAuthNoPriv', );
            $snmpcmds .= " -l noAuthNoPriv";
        }

        # Auth Protocols
        if ($opt_authproto) {
            %snmpv3ap = ( AuthProto   => $opt_authproto, );
            $snmpcmds .= " -a $opt_authproto";
        }
        if ($opt_privproto) {
            %snmpv3pp = ( PrivProto   => $opt_privproto, );
            $snmpcmds .= " -x $opt_privproto";
        }

        # Auth Passphrase or Key
        if ($opt_authpass) {
            %snmpv3aa = ( AuthPass   => $opt_authpass, );
            $snmpcmds .= " -A '" . $opt_authpass . "'";
        }
        if ($opt_authkey) {
            %snmpv3aa = ( AuthLocalizedKey   => $opt_authkey, );
            $snmpcmds .= " -3k '" . $opt_authkey . "'";
        }
        # Priv Passphrase or Key
        if ($opt_privpass) {
            %snmpv3pa = ( PrivPass   => $opt_privpass, );
            $snmpcmds .= " -X '" . $opt_privpass . "'";
        }
        if ($opt_privkey) {
            %snmpv3pa = ( PrivLocalizedKey   => $opt_privkey, );
            $snmpcmds .= " -3K '" . $opt_privkey . "'";
        }

        %snmpv3 = ( %snmpv3, %snmpv3pl, %snmpv3ap, %snmpv3pp, %snmpv3aa, %snmpv3pa );

        if ( $opt_contextname ) {
            %snmpv3 = ( %snmpv3, Context    => $opt_contextname, );
            $snmpcmds .= " -n $opt_contextname";
        }
    }
    $snmpcmds .= " $hostip ";
    if ( $opt_snmpver le 2 ) {
        %snmpargs = ( %snmpargs, %snmpv12 );
    } elsif ( $opt_snmpver eq 3 ) {
        %snmpargs = ( %snmpargs, %snmpv3 );
    } else {
        $state = 'UNKNOWN';
        stop( "$state: It appears you are missing one or more parameters necessary for v$opt_snmpver to function.\n",$state );
    }

    if ($opt_debug) {
        %dbgsnmpargs = %snmpargs;
        $dbgsnmpcmds = $snmpcmds;
    }

    if ($opt_redact) {
        print "[Scrubbing data before printing to console....]\n";
        if (scalar(%dbgsnmpargs)->{DestHost} =~ /(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/) { scalar(%dbgsnmpargs)->{DestHost} = '<redacted_IP>'; }
        if (scalar(%dbgsnmpargs)->{SecName}) { scalar(%dbgsnmpargs)->{SecName} = '<redacted_User>'; }
        if (scalar(%dbgsnmpargs)->{AuthPass}) { scalar(%dbgsnmpargs)->{AuthPass} = '<redacted_AuthPass>'; }
        if (scalar(%dbgsnmpargs)->{AuthKey}) { scalar(%dbgsnmpargs)->{AuthKey} = '<redacted_AuthKey>'; }
        if (scalar(%dbgsnmpargs)->{PrivPass}) { scalar(%dbgsnmpargs)->{PrivPass} = '<redacted_PrivPass>'; }
        if (scalar(%dbgsnmpargs)->{PrivKey}) { scalar(%dbgsnmpargs)->{PrivKey} = '<redacted_PrivKey>'; }
        if (scalar(%dbgsnmpargs)->{Context}) { scalar(%dbgsnmpargs)->{Context} = '<redacted_Context>'; }
        ($dbgsnmpcmds = $dbgsnmpcmds) =~ s/(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/<redacted_IP>/g;
        ($dbgsnmpcmds = $dbgsnmpcmds) =~ s/-u \w+/-u <redacted_User>/g;
        ($dbgsnmpcmds = $dbgsnmpcmds) =~ s/-A '\w+'/-A <redacted_AuthPass>/g;
        ($dbgsnmpcmds = $dbgsnmpcmds) =~ s/-3k '\w+'/-3k <redacted_AuthKey>/g;
        ($dbgsnmpcmds = $dbgsnmpcmds) =~ s/-X '\w+'/-X <redacted_PrivPass>/g;
        ($dbgsnmpcmds = $dbgsnmpcmds) =~ s/-3K '\w+'/-3K <redacted_PrivKey>/g;
        ($dbgsnmpcmds = $dbgsnmpcmds) =~ s/-n \w+/-n <redacted_Contxt>/g;
    }

    if ($opt_debug ge 1) { print Dumper(\%dbgsnmpargs); }

    $snmp = new SNMP::Session( %snmpargs );
}

sub check_reachability {
    use Socket;
    if ($opt_debug) { print "[Checking to see if host was entered as an IP address]\n"; }
    if ($opt_host =~ /(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/) { $isip = 1; }
    if ($opt_debug) { if ($isip) { print "....it was.\n"; } else { print "....it was not.\n"; } }

    # Check host for connectivity before proceeding
    if ($opt_debug) { print "[Checking host for availability]\n"; }
    my $hstatus = get_host_status($hostip);

    # Convert hostname to IP as needed
    if (!$isip) {
        if ($opt_debug) {
            print "[Converting host to an IP address]\n";
            print "....from: $opt_host\n";
        }
        $hostip = inet_aton($opt_host);
        if (!$hostip) {
            if ($opt_debug) { print "....could not locate a DNS entry.\n....conversion unsucessful.\n"; }
            $hostip = $opt_host;
            return;
        }
        $hostip = inet_ntoa($hostip);
        if ($hostip =~ /(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/) {
            if ($opt_debug) {
                print "....to: ";
                if ($opt_redact) { print "<redacted_IP>\n"; } else { print "$hostip\n"; }
                print "....conversion successful.\n";
            }
        } else {
            if ($opt_debug) {
                print "....failed to convert to IP address.\n";
                print "....reverting hostip variable.\n";
            }
            $hostip = $opt_host;
        }
    } else { $hostip = $opt_host; }
}

sub get_host_status {
    use Net::Ping;

    my $p = Net::Ping->new();
    my $isUp = $p->ping($opt_host);

    if ($opt_debug) {
        if (($opt_redact) && ($isip)) { print "....<redacted_IP> is "; } else { print "....$opt_host is "; }
        print "NOT " unless $isUp;
        print "reachable by ping.\n";
    }
}

sub check_model {
    my ($pcheck) = @_;
    my $oid;
    my $MODEL="Unknown model";
    my $SERIAL="";
    if ($pcheck == 1 || $pcheck == 2) {
        $oid="1.3.6.1.2.1.25.3.2.1.3.1";
        eval {
            $MODEL=$snmp->get([$oid]);
            1
        } or do {
            my $e = $@ || 'Unknown error';
            print "$e\n";
        };
        if ($MODEL =~ /(Lexmark \w+) (\w+) (\w+\.\w+\.\w+)/ ) { $MODEL = $1; $SERIAL = $2; }
        if ($snmp->{ErrorStr}) {
            if ($snmp->{ErrorStr} =~ m/Timeout/ and ($opt_ignoffline)) {
                stop("OK - Printer offline and check was ignored.", 'OK');
            } else {
                stop("CRITICAL - $snmp->{ErrorStr}", 'CRITICAL');
            }
        }
        if ($pcheck == 2) { return lc $MODEL; }
    }
    if ($pcheck == 1) {
        if (!$MODEL =~ m/Lexmark/) {
            $oid=".1.3.6.1.2.1.43.5.1.1.17.1";
            $SERIAL=$snmp->get([$oid]);
            $SERIAL =~ s/\"//g;
        }
        print "$MODEL, Serial # $SERIAL\n";
    }
}

sub check_messages {
    my ($mcheck) = @_;
    my ($oid,$result,$model,$mcount);
    my @mresults;
    my $k = 0;
    my $MESSAGES = "";

    $model = check_model(2);
    if ($model =~ m/hp/) {
        $oid=".1.3.6.1.4.1.11.2.3.9.1.1.3";
    } else {
        $oid=".1.3.6.1.2.1.43.16";
    }

    my @result = $snmp->bulkwalk(0, 10, $oid);
    for my $key (@result) {
        for my $v (@$key) {
            push @{ $mresults[$k] }, $v->[0], $v->[2];
        }
        $k++;
    }
    $k = 0;
    @mresults = sort { $a->[0] cmp $b->[0] } @mresults;
    $mcount = (scalar @mresults);
    while ($mcount > 0) {
        if ($mresults[$k][1] ne "") {
            $MESSAGES .= "$mresults[$k][1]";
            if ($mcount > 1) {
                $MESSAGES .= " / ";
            }
        }
        $mcount--;
        $k++;
    }

    chomp $MESSAGES;
    if ((substr $MESSAGES, -3) eq " / ") { $MESSAGES =~ s/.{3}$//; }

    if ($MESSAGES eq "") {
        $MESSAGES= "(Can't determine messages)";
    }
    if ($mcheck == 2) { return $MESSAGES; }
    my @messages = split('\n',$MESSAGES);
    foreach my $message (@messages) {
        $message = lc $message;
        if ($message =~ m/toner low|wenig toner|cartridge low|niedrig|attention|reorder/) {
            $state = "WARNING";
        }
        elsif ($message =~ m/replace toner|toner ersetzen|error|paper is out/) {
            $state = "CRITICAL";
        } else { $state = "OK"; }
        push @{ $status[$mnumber] }, $state;
        $mnumber++;
    }
    print "$MESSAGES\n";
}

sub check_firmware {
    use Time::Piece;
    use Time::Seconds;
    my ($ldy, $dt);

    my ($model,$fwdate,$fwrev,$fwupg,$fwinst);
    $model = check_model(2);

    if ($model =~ m/hp/) {
        $fwdate = $snmp->get(['.1.3.6.1.4.1.11.2.3.9.4.2.1.1.3.5.0']);
        $fwrev = $snmp->get(['.1.3.6.1.4.1.11.2.3.9.4.2.1.1.3.6.0']);
    } elsif ($model =~ m/xerox/) {
        (localtime->yy) =~ /\d(\d)/;
        my $ldy = $1;
        $fwrev = $snmp->get(['.1.3.6.1.2.1.25.6.3.1.2.2']);
        chomp($fwupg = `snmpget $snmpcmds .1.3.6.1.2.1.25.6.3.1.5.2`);
        if ($opt_debug) { print "snmpget $dbgsnmpcmds .1.3.6.1.2.1.25.6.3.1.5.2\n"; }
        if ( $fwrev =~ /(\d+\.\d+\.\d+\.\d+)/ ) { $fwrev = $1; }
        if ( $fwrev =~ /(\d)\.(\d\d\d)\d\d/ ) { 
            if ($1 gt $ldy) {
                $dt = Time::Piece->strptime( "201" . $1 . "0101", '%Y%m%d');
            } else {
                $dt = Time::Piece->strptime( "202" . $1 . "0101", '%Y%m%d');
            }
            $dt += ONE_DAY * $2;
            $fwdate = $dt->strftime('%Y%m%d');
        }
        if ( $fwupg =~ /(\d+-\d+-\d+)\,(\d+:\d+:\d+)/ ) { $fwinst = "Installed on: $1 at $2\n"; }
    } elsif ($model =~ m/kyocera|ecosys|taskalfa|4200dn/) {
        $fwrev = $snmp->get(['.1.3.6.1.4.1.1347.43.5.4.1.5.1.1']);
    } elsif ($model =~ m/canon/) {
        $fwrev = $snmp->get(['.1.3.6.1.4.1.1602.1.1.1.4.0']);
    } elsif ($model =~ m/lexmark/) {
        $fwrev = $snmp->get(['.1.3.6.1.2.1.25.3.2.1.3.1']);
        if ($fwrev =~ /Lexmark \w+ \w+ (\w+)\.(\w+)\.(\w+)/ ) { $fwrev = "$1.$2.$3"; }
        if ($1 eq "LW20") { $fwdate = "August 2013"; }
        if ($1 eq "LW30") { $fwdate = "March 2014"; }
        if ($1 eq "LW40") { $fwdate = "July 2014"; }
        if ($1 eq "LW41") { $fwdate = "May 2015"; }
        if ($1 eq "LW50") { $fwdate = "April 2015"; }
        if ($1 eq "LW60") { $fwdate = "February 2016"; }
        if ($1 eq "LW62") { $fwdate = "November 2016"; }
        if ($1 eq "LW63") { $fwdate = "August 2017"; }
        if ($1 eq "LW70") { $fwdate = "June 2018"; }
        if ($1 eq "LW71") { $fwdate = "October 2018"; }
        if ($1 eq "LW72") { $fwdate = "May 2019"; }
        if ($1 eq "LW73") { $fwdate = "August 2019"; }
        if ($1 eq "LW74") { $fwdate = "December 2019"; }
        if ($1 eq "LW75") { $fwdate = "March 2020"; }
        if ($1 eq "LW80") { $fwdate = "January 2022"; }
    } elsif ($model =~ m/ricoh/) {
        $fwrev = $snmp->get(['.1.3.6.1.4.1.367.3.2.1.2.20.1.2.1.1']);
    }
    if (!$fwrev) { $EXITSTRING = "No current firmware found for this printer. Make a feature request to have it added."; }
    else { $EXITSTRING = "Revision: $fwrev"; }
    if ($fwdate) { $EXITSTRING .= " (Date: $fwdate)\n"; } else { $EXITSTRING .= "\n"; }
    if ($fwinst) { $EXITSTRING .= $fwinst; }
    stop($EXITSTRING, 'OK');
}

sub check_page_count {
    my ($oid,$result,$model,$t_oid,$c_oid,$m_oid,
        $m_a3_oid,$m_a4_oid,$c_a3_oid,$c_a4_oid,
        $m_a3,$m_a4,$c_a3,$c_a4,$MonoPagecount,$ColorPagecount,$TotalPagecount);
    my (%ttmpprs,%ctmpprs,%mtmpprs) = ();

    $model = check_model(2);
    if ($model =~ m/hp/) {
        $c_oid='.1.3.6.1.4.1.11.2.3.9.4.2.1.4.1.2.7.0';
        $m_oid='.1.3.6.1.4.1.11.2.3.9.4.2.1.4.1.2.6.0';
    }
    if ($model =~ m/canon/) {
        $t_oid='.1.3.6.1.4.1.1602.1.11.1.3.1.4.101';
        $c_oid='.1.3.6.1.4.1.1602.1.11.1.3.1.4.105';
        $m_oid='.1.3.6.1.4.1.1602.1.11.1.3.1.4.108';
        $m_a3_oid='.1.3.6.1.4.1.1602.1.11.1.3.1.4.112';
        $m_a4_oid='.1.3.6.1.4.1.1602.1.11.1.3.1.4.113';
        $c_a3_oid='.1.3.6.1.4.1.1602.1.11.1.3.1.4.222';
        $c_a4_oid='.1.3.6.1.4.1.1602.1.11.1.3.1.4.223';
    }
    if ($model =~ m/xerox/) {
        $c_oid='.1.3.6.1.4.1.253.8.53.13.2.1.6.1.20.33';
        $m_oid='.1.3.6.1.4.1.253.8.53.13.2.1.6.1.20.34';
    }
    if ($model =~ m/lexmark/) {
        $c_oid='.1.3.6.1.4.1.641.6.4.2.2.1.7.1.1';
        $m_oid='.1.3.6.1.4.1.641.6.4.2.2.1.6.1.1';
    }
    if ($model =~ m/ricoh/) {
        $c_oid='.1.3.6.1.4.1.367.3.2.1.2.19.5.1.9.21';
        $m_oid='.1.3.6.1.4.1.367.3.2.1.2.19.5.1.9.22';
    }
    if ($model =~ m/kyocera|ecosys|taskalfa|4200dn/) {
        $t_oid='.1.3.6.1.4.1.1347.42.2.1.1.1.6.1';
        $c_oid='.1.3.6.1.4.1.1347.42.2.1.1.1.8.1';
        $m_oid='.1.3.6.1.4.1.1347.42.2.1.1.1.7.1';
    }

    $oid=".1.3.6.1.2.1.43.10.2.1.4.1.1";

    if (defined($snmp->get([$m_a3_oid]))) { $m_a3 = $snmp->get([$m_a3_oid]) }
    if (defined($snmp->get([$m_a4_oid]))) { $m_a4 = $snmp->get([$m_a4_oid]) }
    if (defined($snmp->get([$c_a3_oid]))) { $c_a3 = $snmp->get([$c_a3_oid]) }
    if (defined($snmp->get([$c_a4_oid]))) { $c_a4 = $snmp->get([$c_a4_oid]) }
    if (($m_a3 || $m_a4) > 0) {
        $MonoPagecount = $m_a3 + $m_a4;
    } elsif ($model =~ m/kyocera|ecosys|taskalfa|4200dn/) {
        my @tresult = $snmp->bulkwalk(0, 20, $t_oid);
        my @cresult = $snmp->bulkwalk(0, 20, $c_oid);
        my @mresult = $snmp->bulkwalk(0, 20, $m_oid);
        for my $tkey (@tresult) {
            for my $tval (@$tkey) {
                $TotalPagecount = $TotalPagecount + $tval->[2];
            }
        }
        for my $ckey (@cresult) {
            for my $cval (@$ckey) {
                $ColorPagecount = $ColorPagecount + $cval->[2];
            }
        }
        for my $mkey (@mresult) {
             for my $mval (@$mkey) {
                 $MonoPagecount = $MonoPagecount + $mval->[2];
             }
        }
    } else {
        $result=$snmp->get([$m_oid]);
        if((not defined($result)) || (lc($result) eq 'nosuchinstance') || (lc($result) eq 'nosuchobject')) {
            $result=$snmp->get([$t_oid]);
            if((not defined($result)) || (lc($result) eq 'nosuchinstance') || (lc($result) eq 'nosuchobject')) {
                $result=$snmp->get([$oid]);
                if(not defined($result)) {
                    $state = "CRITICAL";
                    $EXITSTRING = "$state - " . $snmp->{ErrorStr} . "\n";
                    stop($EXITSTRING, $state);
                } else { $TotalPagecount=$result; }
            } else { $TotalPagecount=$result; }
        } else { $MonoPagecount=$result; }
    }
    if (($c_a3 || $c_a4) > 0) {
        $ColorPagecount = $c_a3 + $c_a4;
    } else {
        $result=$snmp->get([$c_oid]);
        if(not defined($result)) {
        } else { $ColorPagecount=$result; }
    }
    if (($TotalPagecount) or (($model =~ m/kyocera|ecosys|taskalfa|4200dn/))) {
        $EXITSTRING = "Pagecount is $TotalPagecount";
        if ($model =~ m/kyocera|ecosys|taskalfa|4200dn/) {
            $EXITSTRING.= " Total, $MonoPagecount Black-and-White";
        }
    } else { $EXITSTRING = "Pagecount is $MonoPagecount Black-and-White"; }
    if ($ColorPagecount > 0) {
        $EXITSTRING.= ", $ColorPagecount Color";
    }
    $EXITSTRING.= "\n";
    if (($TotalPagecount) or ($model =~ m/kyocera|ecosys|taskalfa|4200dn/)) {
        $EXITSTRING.= "|Total=$TotalPagecount;;;;";
        if ($model =~ m/kyocera|ecosys|taskalfa|4200dn/) {
            $EXITSTRING.= " Black-and-White=$MonoPagecount;;;;";
        }
    } else { $EXITSTRING.= "|Black-and-White=$MonoPagecount;;;;"; }
    if ($ColorPagecount > 0) {
        $EXITSTRING.= " Color=$ColorPagecount;;;;";
    }
}

sub get_consumables {
    my ($result,$Table,$Names,$CurCap,$MaxCap) = @_;
    my %tmpprs = ();
    my ($consumable, $curcap_pct, $inum);
    my ($puncher, $found) = 0;

    foreach my $key (keys(%$result)) {
        my($base, $index) = ($key =~ /($Table\.\d+\.\d+)\.(\d+)/);
        if($base eq $Names ) {
            $result->{$key} =~ s/[^\w\s]//g;
            $tmpprs{$index}{name} = $result->{$key};
        }
        if($base eq $CurCap) { $tmpprs{$index}{curcap} = $result->{$key}; }
        if($base eq $MaxCap) { $tmpprs{$index}{maxcap} = $result->{$key}; }
    }

    foreach my $key (keys(%tmpprs)) {
        my $name=$tmpprs{$key}{name};
        if ($name =~ m/Imaging Unit|Imaging Kit|Patrone|Cartouche|Unité|Courroie|Kit d/) {
            if ($name =~ /(\w+) Imaging Unit/) {
                $consumable = "$1 Imaging Unit";
            } else {
                $consumable = $name;
            }
        }
        else { ($consumable = $name) =~ s/(\w+).*/$1/; }
        if (($consumable =~ m/Fuser|Fixiererkit/ and $opt_nofuser)) { next; }
        if ($consumable eq "Canon") {
            my @split = split(' ',$consumable = $name);
            foreach my $cconsumable (@split) {
                if ($cconsumable =~ m/Black|Yellow|Magenta|Cyan/) { $consumable = $cconsumable; }
                else { next; }
            }
        }
        if ($consumable eq "Image") {
            my @split = split(' ',$consumable = $name);
            foreach my $iconsumable (@split) {
                if ($iconsumable =~ m/Transfer|Fuser/) { $consumable = $iconsumable. " Kit"; }
                else { next; }
            }
        }
        if (check_model(2) =~ m/generic 30c-9/) {
            my @split = split(' ',$consumable = $name);
            foreach my $gconsumable (@split) {
                if ($gconsumable =~ m/Toner/) {
                    ($consumable) = $name =~ /\((.*)\)/;
                } elsif ($gconsumable =~ m/Image|Fusing/) {
                    $consumable = $name;
                } else {
                    next;
                }
            }
        }
        if (check_model(2) =~ m/ricoh/) {
            my @split = split(' ',$consumable = $name);
            foreach my $rconsumable (@split) {
                if ($rconsumable =~ m/Toner/) {
                    ($consumable) = $name =~ /(?:Toner\s+(\w+))|(?:(\w+)\s+Toner)/;
                    $consumable = $1 || $2 if (defined $1 || defined $2);
                 } else {
                    next;
                 }
            }
        }

        my $curcap=$tmpprs{$key}{curcap};
        my $maxcap=$tmpprs{$key}{maxcap};
        if ($name =~ m/Drum|Resttoner|Waste|Belt|Developer|200K|300K|Photoconductor|Staples G|Trommel|Tambour|dév|récupération/) {
            next;
        }
        if ($name =~ m/Main Staple/) { $consumable = "Staples"; }
        if ($name =~ m/Transfer Roll/) { $consumable = "Transfer"; }
        if ($opt_lang eq 'english') {
            if ($consumable =~ m/noir|Noir/) { $consumable = "Black"; }
            if ($consumable =~ m/jaune|Jaune/) { $consumable = "Yellow"; }
            if ($consumable =~ m/Courroie de transfert/) { $consumable = "Transfer Belt"; }
            if ($consumable =~ m/Rouleaux|Wazlen/) { $consumable = "Clean Rollers"; }
            if ($consumable =~ m/Rouleau d/) { $consumable = "Pickup Rollers"; }
            if ($consumable =~ m/Rouleau s/) { $consumable = "Separation Roller"; }
            if ($consumable =~ m/Kit du rouleau du bac/) {
                ($inum) = $name =~ /(?<=Kit du rouleau du bac )(\d+)/;
                $consumable = "Bin Roller Kit" . " $inum";
            }
            if ($consumable =~ m/Fixiererkit|Kit de fusion/) { $consumable = "Fuser Kit"; }
            if ($consumable =~ m/Tonerauffangeinheit/) { $consumable = "Toner Collection Kit"; }
            if ($consumable =~ m/Hefter/) { $consumable = "Stapler"; }
            if ($consumable =~ m/Transferkit/) { $consumable = "Transfer Kit"; }
        }
        # German
        if ($consumable =~ m/Fixiererkit/) { $consumable = "Fixiererkit"; }
        if ($consumable =~ m/Wazlen/) { $consumable = "Walzen reinigen"; }
        if ($consumable =~ m/Tonerauffangeinheit/) { $consumable = "Tonerauffangeinheit"; }
        if ($consumable =~ m/Hefter/) { $consumable = "Hefter"; }
        if ($consumable =~ m/Transferkit/) { $consumable = "Transferkit"; }
        # French
        if ($consumable =~ m/noir|Noir/) { $consumable = "Toner Noir"; }
        if ($consumable =~ m/jaune|Jaune/) { $consumable = "Toner Juane"; }
        if ($consumable =~ m/Courroie de transfert/) { $consumable = "Courroie de transfert"; } 
        if ($consumable =~ m/Rouleaux/) { $consumable = "Rouleaux de transfert"; }
        if ($consumable =~ m/Rouleau d/) { $consumable = "Rouleau d'entraînement"; }
        if ($consumable =~ m/Rouleau s/) { $consumable = "Rouleau séparation"; }
        if ($consumable =~ m/Kit de fusion/) { $consumable = "Kit de fusion"; }
        if ($consumable =~ m/Kit du rouleau du bac/)  {
            ($inum) = $name =~ /(?<=Kit du rouleau du bac )(\d+)/;
            $consumable = "Kit du rouleau du bac" . " $inum";
        }

        if ($consumable =~ m/Imaging Unit|Vorlageneinzugskit|nettoyage/) { }
        elsif ($consumable =~ m/Patrone/) { # German 
            if ($opt_lang eq 'english') {
                if ($consumable =~ m/Schwarz/) { $consumable = "Black Toner"; }
                if ($consumable =~ m/Gelb/) { $consumable = "Yellow Toner"; }
                if ($consumable =~ m/Magenta/) { $consumable = "Magenta Toner"; }
                if ($consumable =~ m/Cyan/) { $consumable = "Cyan Toner"; }
            } else {
                if ($consumable =~ m/Schwarz/) { $consumable = "Patrone Schwarz"; }
                if ($consumable =~ m/Gelb/) { $consumable = "Patrone Gelb"; }
                if ($consumable =~ m/Magenta/) { $consumable = "Patrone Magenta"; }
                if ($consumable =~ m/Cyan/) { $consumable = "Patrone Cyan"; }
            }
        }
        elsif ($consumable =~ m/Black|Yellow|Magenta|Cyan/) { $consumable = $consumable." Toner"; }
        elsif ($consumable =~ m/Schwarz|Gelb/) {
            if ($opt_lang = 'english') {
                # German
                if ($consumable =~ m/Schwarz/) { $consumable = "Black"; }
                if ($consumable =~ m/Gelb/) { $consumable = "Yellow"; }
            }
            $consumable = $consumable." Toner";
        }
        # Kyocera reports toner as model number so we need to convert that to something human readable
        if ($consumable =~ m/TK|CK/) {
            if ($consumable =~ /CS$|C$/) { $consumable = "Cyan Toner"; }
            elsif ($consumable =~ /MS$|M$/) { $consumable = "Magenta Toner"; }
            elsif ($consumable =~ /YS$|Y$/) { $consumable = "Yellow Toner"; }
            elsif ($consumable =~ /KS$|K$/) { $consumable = "Black Toner"; }
            else { $consumable = "Black Toner"; }
        }
        # Some HP reports toner as model number so we need to convert that to something human readable
        if ($consumable =~ m/CE/) {
            if ($consumable =~ /1A$/) { $consumable = "Cyan Toner"; }
            elsif ($consumable =~ /3A$/) { $consumable = "Magenta Toner"; }
            elsif ($consumable =~ /2A$/) { $consumable = "Yellow Toner"; }
            elsif ($consumable =~ /0A$/) { $consumable = "Black Toner"; }
            else { $consumable = "Black Toner"; }
        }
        if ($name =~ m/Toner cyan|Toner Cyan/) { $consumable = "Toner Cyan"; }
        if ($name =~ m/Toner magenta|Toner Magenta/) { $consumable = "Toner Magenta"; }
        if ($consumable eq 'Magneta') { $consumable = "Magenta Toner"; }  # New HP OID has a typo
        if ($consumable eq 'Clean') { $consumable = $consumable." Rollers"; }
        if ($consumable eq 'Document') { $consumable = $consumable." Feeder Kit"; }
        if ($consumable eq 'Maintenance') { $consumable = $consumable." Kit"; }
        if ($consumable eq 'Transfer') { $consumable = $consumable." Unit"; }
        if ($consumable eq 'Fuser') { $consumable = $consumable." Kit"; }
        if ($consumable eq 'Stapler') { }
        if ($consumable eq 'Staples') { }
        if ($consumable eq 'Saddle') { $consumable = $consumable." Staples"; }
        if ($consumable eq 'Hole') { $puncher = 1; $consumable = $consumable. " Punch Box"; }
        if ($consumable eq 'Puncher') { $puncher = 1; $consumable = $consumable. " Waste"; }
        push (@consumables, $consumable);

        $found=1;
        if ($puncher == 1) {
            if ($curcap > 99) {
                $state = "CRITICAL";
            } elsif ($curcap >= 96) {
                $state = "WARNING";
            } else {
                $state = "OK";
            }
            push (@measurables, '1');
            push (@percentages, $curcap);
        } else {
            if ($maxcap>0 && $curcap>0) {
                $curcap_pct=sprintf("%.2f",$curcap*100/$maxcap);
                if ($curcap_pct<=$opt_critical) {
                    # critical messages come first
                    $state = "CRITICAL";
                } elsif ($curcap_pct<=$opt_warning) {
                    $state = "WARNING";
                } else {
                    $state = "OK";
                }
                push (@measurables, '1');
                push (@percentages, $curcap_pct);
            } elsif ($maxcap == 100 && $curcap == 0) {
                $state = "CRITICAL";
                push (@measurables, '1');
                push (@percentages, 0);
            } else {
                if (check_model(2) =~ m/brother/) {
                    my ($bresult,$bstatus,$boid);
                    if ($consumable =~ m/Black|Schwarz/) {
                        $boid = ".1.3.6.1.4.1.2435.2.3.9.1.1.2.10.1";
                    }
                    if ($consumable =~ m/Cyan/) {
                        $boid = ".1.3.6.1.4.1.2435.2.3.9.1.1.2.10.2";
                    }
                    if ($consumable =~ m/Magenta/) {
                        $boid = ".1.3.6.1.4.1.2435.2.3.9.1.1.2.10.3";
                    }
                    if ($consumable =~ m/Yellow|Gelb/) {
                        $boid = ".1.3.6.1.4.1.2435.2.3.9.1.1.2.10.4";
                    }
                    if (defined($snmp->get($boid))) {
                        $bstatus = $bresult->{$oid};
                        if ($bstatus == 0) { $state = "OK"; push (@measurables, 'b0'); $curcap = 100; }
                        if ($bstatus == 1) { $state = "WARNING"; push (@measurables, 'b1'); $curcap = 10; }
                        if ($bstatus == 2) { $state = "CRITICAL"; push (@measurables, 'b2'); $curcap = 0; }
                        if ($bstatus == 3) { $state = "CRITICAL"; push (@measurables, 'b3'); $curcap = 0; }
                    } else { ($state,$curcap) = nonmeasurable($curcap,$maxcap,$name); }
                } else {
                    $state = nonmeasurable($curcap,$maxcap,$name);
                }
                push (@percentages, $curcap);
            }
        }
        $puncher = 0;
        push @{ $status[$cnumber] }, $state;
        $cnumber++;
    }
}

sub nonmeasurable {
    my ($curcap,$maxcap,$name) = @_;

    # Our object is not measurable - it's either FULL or EMPTY (such as a punch dust box)
    # Let's report on it's status using appropriate terminology
    if (check_model(2) =~ m/brother/) {
        if ($curcap == -3) { $state = "OK"; push (@measurables, 'b0'); }
        else {
            my $smessage = check_messages(2);
            my @messages = split('\n',$smessage);
            foreach my $message (@messages) {
                $message = lc $message;
                if ($message =~ m/toner low|wenig toner/) {
                    $state = "WARNING";
                    push (@measurables, 'b1');
                    $curcap = 10;
                 }
                 elsif ($message =~ m/replace toner|toner ersetzen/) {
                     $state = "CRITICAL";
                     push (@measurables, 'b3');
                     $curcap = 0;
                 }
             }
        }
        push (@measurables, '1');
        return $state, $curcap;
    } elsif ($curcap==-3) {
        if ($maxcap>0) { $state = "WARNING"; push (@measurables, 'lt'); }
        else { $state = "OK"; (@measurables, 'gt'); }
    } elsif ($curcap==-2) {
        # The value (-2) means unknown
        if ($name =~ m/W2020A|W2021A|W2022A|W2023A/) { # HP Color LaserJet Pro M454dw Toner
            $state = "CRITICAL";
            push (@measurables, '1');
        } else { $state = "WARNING"; push (@measurables, '0'); }
    } elsif ($curcap==0) {
        # Something is empty!
        $state = "CRITICAL";
    }
    return $state;
}

sub prioritize_results {
    my ($metric) = @_;
    my ($mcount,$scode);

    if ((scalar @consumables) > 0) { $mcount = (scalar @consumables); }
    if ((scalar @strays) > 0) { $mcount = (scalar @strays); }

    $i = 0;

    while ($mcount > 0) {
        if ($status[$i][0] eq 'CRITICAL') { $scode = 1; }
        if ($status[$i][0] eq 'WARNING') { $scode = 2; }
        if ($status[$i][0] eq 'OK') { $scode = 3; }

        if ($metric eq "consumables") {
            push @{ $mresults[$i] }, $scode, $status[$i][0], $consumables[$i], $message[$i];
        }
        if ($metric eq "trays") {
            push @{ $mresults[$i] }, $scode, $status[$i][0], $strays[$i][0], $message[$i];
        }
        $mcount--;
        $i++;
    }

    @mresults = sort { $a->[0] cmp $b->[0] } @mresults;

    $i = 0;
    $mcount = (scalar @mresults);
    while ($mcount > 0) {
        print "$mresults[$i][1]: $mresults[$i][2]$mresults[$i][3]\n";
        $mcount--;
        $i++;
    }
}

sub check_consumables {
    my %pr_oids = (
        'Table'         => '.1.3.6.1.2.1.43.11.1.1',
        'Names'         => '.1.3.6.1.2.1.43.11.1.1.6.1',
        'CurCap'        => '.1.3.6.1.2.1.43.11.1.1.9.1',
        'MaxCap'        => '.1.3.6.1.2.1.43.11.1.1.8.1',
        'CTable'        => '.1.3.6.1.2.1.43.31.1.1',
        'CNames'        => '.1.3.6.1.2.1.43.31.1.1.5.1',
        'CCurCap'       => '.1.3.6.1.2.1.43.31.1.1.8.1',
        'CMaxCap'       => '.1.3.6.1.2.1.43.31.1.1.7.1'
    );

    my ($consumable,$measurable,$perfcount,$rindex,$result);
    my $pct_remaining = "";
    my %nsioids;
    my $nsicounter = 1;
    my $nsioidrow = 1;
    my @results;
    my (%hresults,%chresults);
        
    @results = ($snmp->bulkwalk(0, 20, $pr_oids{Names}),
                $snmp->bulkwalk(0, 20, $pr_oids{CurCap}),
                $snmp->bulkwalk(0, 20, $pr_oids{MaxCap}));

    if ($snmp->{ErrorStr}) {
        if ($snmp->{ErrorStr} =~ m/Timeout/ and ($opt_ignoffline)) {
            stop("OK - Printer offline and check was ignored.", 'OK');
        } else {
            stop("CRITICAL - $snmp->{ErrorStr}", 'CRITICAL');
        }
    }

    for my $key (@results) {
        for my $v (@$key) {
            $rindex = $v->[0] . "." . $v->[1];
            $hresults{$rindex} = $v->[2];
        }
    }
    my $result = \%hresults;

    if(not defined($result)) {
        if ($snmp->{ErrorStr} =~ m/The requested entries are empty or do not exist/) {
            while ($nsicounter gt 0) {
                my $nsiName = "$pr_oids{Names}.$nsioidrow";
                my $nsiCurCap = "$pr_oids{CurCap}.$nsioidrow";
                my $nsiMaxCap = "$pr_oids{MaxCap}.$nsioidrow";
                my $nsiNresult = $snmp->get($nsiName);
                my $nsiCresult = $snmp->get($nsiCurCap);
                my $nsiMresult = $snmp->get($nsiMaxCap);
                if (lc($nsiNresult->{$nsiName}) eq "nosuchinstance") { $nsicounter = 0; }
                else {
                    %nsioids = (%nsioids,
                                $nsiName => $nsiNresult->{$nsiName},
                                $nsiCurCap => $nsiCresult->{$nsiCurCap},
                                $nsiMaxCap => $nsiMresult->{$nsiMaxCap});
                }
                $nsioidrow++;
            }
            $result = \%nsioids;
        } elsif ($snmp->{ErrorStr} =~ m/Timeout/ and ($opt_ignoffline)) {
            stop("OK - Printer offline and check was ignored.", 'OK');
        } else {
            stop("CRITICAL - $snmp->{ErrorStr}", 'CRITICAL');
        }
    }

    my @cresults = ($snmp->bulkwalk(0, 20, $pr_oids{CNames}), 
                    $snmp->bulkwalk(0, 20, $pr_oids{CCurCap}), 
                    $snmp->bulkwalk(0, 20, $pr_oids{CMaxCap}));

    for my $ckey (@cresults) {
        for my $cv (@$ckey) {
            $rindex = $cv->[0] . "." . $cv->[1];
            $chresults{$rindex} = $cv->[2];
        }
    }
    my $cresult = \%chresults;

    get_consumables($result, $pr_oids{Table}, $pr_oids{Names}, $pr_oids{CurCap}, $pr_oids{MaxCap});
    get_consumables($cresult, $pr_oids{CTable}, $pr_oids{CNames}, $pr_oids{CCurCap}, $pr_oids{CMaxCap});

    $tcount = (scalar @consumables);
    if (@percentages != 0 ) { $measurable = 1; }
    if ($measurable) {
        if ($consumables[0] =~ m/Puncher Waste|Hole Punch Box/) {
            $pct_remaining = " is ".$percentages[0]. "% full.";
        } elsif ($consumables[0] eq "Stapler") {
            $pct_remaining = "";
        } elsif (check_model(2) =~ m/brother/) {
            if ($measurables[$i] eq "b0") {
                $pct_remaining = " levels are OK.";
            }
            if ($measurables[$i] eq "b1") {
                $pct_remaining = " levels are LOW.";
            }
            if ($measurables[$i] eq "b2") {
                $pct_remaining = " has no toner installed.";
            }
            if ($measurables[$i] eq "b3") {
                $pct_remaining = " levels are EMPTY.";
            }
        } elsif ($percentages[$i] eq "-2") {
            if ($measurables[$i] eq "0") {
                $pct_remaining = " levels cannot be measured.";
            } else { $pct_remaining = " is at 0% remaining."; }
        } else {
                $pct_remaining = " is at ".$percentages[0]. "% remaining.";
        }
        push (@message, $pct_remaining);
    }
    my $perfcount = $tcount;
    if ($tcount > 1) {
        $tcount--;
        while ($tcount > 0) {
            $i++;
            if ($consumables[$i] eq "Waste") {
                $tcount--;
                next;
            }
            if ($measurable) {
                if ($consumables[$i] =~ m/Puncher Waste|Hole Punch Box/) {
                    $pct_remaining = " is ".$percentages[$i]. "% full.";
                } elsif ($consumables[$i] eq "Stapler") {
                    $pct_remaining = "";
                } elsif (check_model(2) =~ m/brother/) {
                    if ($measurables[$i] eq "b0") {
                        $pct_remaining = " levels are OK.";
                    }
                    if ($measurables[$i] eq "b1") {
                        $pct_remaining = " levels are LOW.";
                    }
                    if ($measurables[$i] eq "b2") {
                        $pct_remaining = " has no toner installed.";
                    }
                    if ($measurables[$i] eq "b3") {
                        $pct_remaining = " levels are EMPTY.";
                    }
                } elsif ($percentages[$i] eq "-2") {
                    if ($measurables[$i] eq "0") {
                        $pct_remaining = " levels cannot be measured.";
                    } else { $pct_remaining = " is at 0% remaining."; }
                    } elsif ($percentages[$i] eq "-3") {
                    if ($measurables[$i] eq "lt") {
                        $pct_remaining = " levels are LOW.";
                    }
                    if ($measurables[$i] eq "gt") {
                        $pct_remaining = " levels are OK.";
                    }
                } else {
                        $pct_remaining = " is at ".$percentages[$i]. "% remaining.";
                }
            }
            push (@message, $pct_remaining);
            $tcount--;
        }
    }
    prioritize_results('consumables');
    $i = 0;
    $EXITSTRING.= "|";
    while ($perfcount > 0) {
        if ($consumables[$i] eq "Waste") {
            $i++;
            $perfcount--;
            next;
        }
        ($consumable = $consumables[$i]) =~ s/ /_/g;
        if ($measurable) {
            if ($consumable eq "Stapler") {
                if ($status[$i] eq 'CRITICAL') { $EXITSTRING.= $consumable."=0"; }
                elsif ($status[$i] eq 'OK') { $EXITSTRING.= $consumable."=100"; }
            } elsif ($percentages[$i] eq "-2") {
                if ($measurables[$i] eq "0") { }
                else { $EXITSTRING.= "$consumable=0"; }
            } else {
                $EXITSTRING.= $consumable."=".$percentages[$i];
            }
        } else {
            if ($status[$i] == "CRITICAL") {
                $EXITSTRING.= $consumable."=0";
            } else {
                $EXITSTRING.= $consumable."=1";
            }
        }
        $i++;
        $perfcount--;
        if ($perfcount == 0) { $EXITSTRING.= ";;;;"; } else { $EXITSTRING.=";;;; "; }
    }
}

sub check_paper_trays {
    my $found=0;
    my %tmpprs = ();
    my ($name,$lcname,$feeder,$cap,$tstatus,$traymessage,$maxcap,$feeddim,$xfeeddim,$cap_pct,$result,$rindex);
    my %hresults;
    my %tray_oids = (
        'Table'         => '.1.3.6.1.2.1.43.8.2.1',
        'Cap'           => '.1.3.6.1.2.1.43.8.2.1.10.1',
        'Status'        => '.1.3.6.1.2.1.43.8.2.1.11.1',
        'MaxCap'        => '.1.3.6.1.2.1.43.8.2.1.9.1',
        'Name'          => '.1.3.6.1.2.1.43.8.2.1.13.1',
        'FeedDim'       => '.1.3.6.1.2.1.43.8.2.1.4.1',
        'FeedDimUnits'  => '.1.3.6.1.2.1.43.8.2.1.2.1',
        'XFeedDim'      => '.1.3.6.1.2.1.43.8.2.1.5.1',
        'XFeedDimUnits' => '.1.3.6.1.2.1.43.8.2.1.3.1'
    );

    my @results = ($snmp->bulkwalk(0, 10, $tray_oids{Name}),
                   $snmp->bulkwalk(0, 10, $tray_oids{Cap}),
                   $snmp->bulkwalk(0, 10, $tray_oids{MaxCap}),
                   $snmp->bulkwalk(0, 10, $tray_oids{FeedDim}),
                   $snmp->bulkwalk(0, 10, $tray_oids{FeedDimUnits}),
                   $snmp->bulkwalk(0, 10, $tray_oids{XFeedDim}),
                   $snmp->bulkwalk(0, 10, $tray_oids{XFeedDimUnits}),
                   $snmp->bulkwalk(0, 10, $tray_oids{Status}));

    for my $key (@results) {
        for my $v (@$key) {
            $rindex = $v->[0] . "." . $v->[1];
            $hresults{$rindex} = $v->[2];
        }
    }
    $result = \%hresults;
    my $model = check_model(2);
    foreach my $key (keys(%$result)) {
        my($base, $index) = ($key =~ /($tray_oids{Table}\.\d+\.\d+)\.(\d+)/);
        $result->{$key} =~ s/\"//g;
        if($base eq $tray_oids{Cap}) { $tmpprs{$index}{cap}  = $result->{$key}; }
        if($base eq $tray_oids{Status}) { $tmpprs{$index}{tstatus}  = $result->{$key}; }
        if($base eq $tray_oids{MaxCap}) { $tmpprs{$index}{maxcap}  = $result->{$key}; }
        if($base eq $tray_oids{Name}) { $tmpprs{$index}{name} = $result->{$key}; }
        if($base eq $tray_oids{FeedDim}) { $tmpprs{$index}{feeddim} = $result->{$key}; }
        if($base eq $tray_oids{XFeedDim}) { $tmpprs{$index}{xfeeddim} = $result->{$key}; }
    }

    if ($opt_nofeeder) {
        foreach my $key (keys(%tmpprs)) {
            if (lc($tmpprs{$key}{name}) =~ m/bypass|mp tray|manual paper|manual envelope|multi-purpose_tray/) { $feeder=1; }
        }
    }

    foreach my $key (keys(%tmpprs)) {
        $name=$tmpprs{$key}{name};
        $cap=$tmpprs{$key}{cap};
        $tstatus=$tmpprs{$key}{tstatus};
        $maxcap=$tmpprs{$key}{maxcap};
        $feeddim=$tmpprs{$key}{feeddim};
        $xfeeddim=$tmpprs{$key}{xfeeddim};

        # if name is empty, make one with the number
        if ($name eq "") {
            $name="Tray $key";
        }
        if ($name =~ m/(MPT)/) {
            $name =~ s/ \(MPT\)//g;
        }
        if ($name =~ m/Paper Tray/) {
            ($name) = $name =~ /[^ ]* (.*)/;
        }
        $name =~ s/\n/\!/g;
        if ($name =~ m/TRAY/) {
            if ($name =~ /(?<=TRAY)[0-9]/) {
                my @split = split(/(?<=\d)(?=\D)|(?<=\D)(?=\d)/, $name);
                $name = @split[0]." ".@split[1];
            }
            $name = (ucfirst(lc($name)));
        }
        $lcname = lc($name);
        if ($opt_nofeeder) {
            if (($lcname =~ m/tray 1/) and (scalar(keys(%tmpprs) > 1)) and (!$feeder)) { next; }
            elsif ($lcname =~ m/bypass|mp tray|manual paper|manual envelope|multi-purpose_tray/) { next; }
        }
        $found=1;
        push @{ $trays[$traynumber] }, $name, $cap, $maxcap, $feeddim, $xfeeddim, $tstatus;
        $traynumber++;
    }

    $traynumber = 0;
    @strays = sort { $a->[0] cmp $b->[0] } @trays;
    $tcount = scalar(@strays);
    my $perfcount = $tcount;

    while  ($tcount > 0) {
        $name           = $strays[$i][0];
        $cap            = $strays[$i][1];
        $maxcap         = $strays[$i][2];
        $feeddim        = $strays[$i][3];
        $xfeeddim       = $strays[$i][4];
        $tstatus        = $strays[$i][5];
        $lcname         = lc($name);

        if ($feeddim eq '-2') { $feeddim = "Any"; }
        if ($xfeeddim eq '-2') { $xfeeddim = "Any"; }

        $model = check_model(2);
        if (($feeddim || $xfeeddim) ne 'Any') {
            if ($model =~ m/canon|xerox|ricoh|brother/) {
                if ($opt_metric) {
                    $feeddim = sprintf("%.0f", $feeddim * .001)."mm";
                    $xfeeddim = sprintf("%.0f", $xfeeddim * .001)."mm";
                } else {
                    $feeddim = sprintf("%.2f", (($feeddim / 2.54) * .0001))."in";
                    $xfeeddim = sprintf("%.2f", (($xfeeddim / 2.54) * .0001))."in";
                }
            } else {
                if ($opt_metric) {
                    $feeddim = sprintf("%.0f", (($feeddim * 2.54) * .001))."mm";
                    $xfeeddim = sprintf("%.0f", (($xfeeddim * 2.54) * .001))."mm";
                 } else {
                    $feeddim = sprintf("%.2f", $feeddim * .0001)."in";
                    $xfeeddim = sprintf("%.2f", $xfeeddim  * .0001)."in";
                 }
             }
         }
         if ($cap == -3) {
             # The value (-3) means that the printer knows that at least one unit remains.
             if ($model =~ m/lexmark/) { # When -3, Lexmark is really low status.
                 if (($opt_critical == 0) or ($opt_warning == 0 )) {
                     $state = "OK";
                 } else {
                     $state = "WARNING";
                 }
                 $traymessage = " is LOW. ($xfeeddim x $feeddim)";
             } else {
                 $state = "OK";
                 $traymessage = " ($xfeeddim x $feeddim)";
             }
         } elsif ($cap == -2) {
             # The value (-2) means unknown
             # so lets check the tray status instead
             if ($tstatus eq '0') {
                 if ($model =~ m/canon|hp|ricoh/) {
                     $state = "OK";
                     $traymessage = " ($xfeeddim x $feeddim)";
                 } else {
                     $state = "WARNING";
                     $traymessage = " is in an UNKNOWN state.";
                 }
             if (($lcname =~ m/tray 1|stack bypass|mp tray|manual paper|manual envelope|multi-purpose_tray/) and ($state ne 'WARNING')) {
                 $traymessage = "";
             }
         } elsif ($tstatus eq '4') {
             if ($model =~ m/lexmark/) {
                 $state = "OK";
                 $traymessage = " ($xfeeddim x $feeddim)";
             }
         } elsif ($tstatus eq '9') {
             if ($model =~ m/hp/) {
                 $state = "OK";
                 $traymessage = " ($xfeeddim x $feeddim)";
             }
         } else {
             # still unknown so we'll mark it warning because we just don't know
             $state = "WARNING";
             $traymessage = " is in UNKNOWN status.";
         }
         if ($opt_warning == 0) { $state = "OK"; }
         } elsif ($cap == 0) {
             # 0 means there is no paper left! This is our only critical value.
             # first lets check to see if it's a bypass tray, we'll always assume Tray 1 is such.
             if ($lcname =~ m/tray 1|stack bypass|mp tray|manual paper|manual envelope|multi-purpose_tray/) {
                 $state = "CRITICAL";
                 if (($xfeeddim || $feeddim) ne 'Any') {
                     $traymessage = " ($xfeeddim x $feeddim)";
                 } else { $traymessage = " is empty."; }
             } else {
                 if ($opt_critical > 0) {
                     $state = "CRITICAL";
                 } else {
                     $state = "OK";
                 }
                 $traymessage = " ($xfeeddim x $feeddim) is at 0% paper remaining.";
             }
                 $cap_pct=sprintf("%.2f",$cap*100/$maxcap);
                 if ($opt_critical == 0) { $state = "OK"; }
         } else {
             ($maxcap==0) && ($maxcap=1);
             $cap_pct=sprintf("%.2f",$cap*100/$maxcap);
             if (($cap_pct <= $opt_warning) and ($opt_warning > 0 )) {
                 $state = "WARNING";
             } else {
                 $state = "OK";
             }
             $traymessage = " ($xfeeddim x $feeddim) is at $cap_pct% paper remaining.";
             if ($opt_warning == 0 ) { $state = "OK"; }
         }
         push @{ $status[$traynumber] }, $state, $cap_pct;
         push (@message, $traymessage);
         $traynumber++;
         $tcount--;
         $i++;
     }
     prioritize_results('trays');
     $i = 0;
     $EXITSTRING.= "|";
     while ($perfcount > 0) {
         (my $tray = $strays[$i][0]) =~ s/ /_/g;
         if ($status[$i][0] eq 'CRITICAL') {
             if ($status[$i][1] != "") {
                 $EXITSTRING.= $tray."=$status[$i][1]";
             } else { $EXITSTRING.= $tray."=0"; }
         }
         if ($status[$i][0] eq 'WARNING') {
             if ($status[$i][1] != "") {
                 $EXITSTRING.= $tray."=$status[$i][1]";
             } else { $EXITSTRING.= $tray."=10"; }
         }
         if ($status[$i][0] eq 'OK') {
             if ($status[$i][1] != "") {
                 $EXITSTRING.= $tray."=$status[$i][1]";
             } else { $EXITSTRING.= $tray."=100"; }
         }
         $i++;
         $perfcount--;
         if ($perfcount == 0) { $EXITSTRING.= ";;;;"; } else { $EXITSTRING.=";;;; "; }
    }
}

# set alarm in case we hang
$SIG{ALRM} = sub {
    if ($opt_ignoffline) {
        stop("OK - Printer offline and check ignored.", "OK");
    } else {
      print "CRITICAL - Timeout after $opt_timeout seconds\n";
      exit($ERRORS{'CRITICAL'});
   }
};
alarm($opt_timeout*$opt_retries);

check_reachability();
initialize_snmp();

if ($opt_messages) {check_messages();}
if ($opt_model) {check_model(1); exit($ERRORS{'OK'});}
if ($opt_pagecount) {check_page_count();}
if ($opt_consum) {check_consumables();}
if ($opt_firmware) {check_firmware();}
if (defined($opt_tray)) {check_paper_trays($opt_tray);}

$i = 0;
$scount = (scalar @status);
while ($scount > 0) {
    if ($status[$i][0] eq "CRITICAL") { $critcount++; }
    if (($status[$i][0] eq "WARNING") && ($state ne "CRITICAL")) { $warncount++; }
    $scount--;
    $i++;
}

if ($critcount > 0) { $state = "CRITICAL"; }
elsif ($warncount > 0) { $state = "WARNING"; }
else { $state = "OK"; }

stop($EXITSTRING, $state);
sub stop {
    my $result = shift;
    my $exit_code = shift;
    print $result . "\n";
    exit ( $STATUS_CODE{$exit_code} );
}
